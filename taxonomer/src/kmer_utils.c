//
//  kmer_utils.c
//  taxonomer
//
//  Created by steven on 10/3/14.
//  Copyright (c) 2014 yandell lab. All rights reserved.
//

#include "kmer_utils.h"

//kraken source
uint64_t kmer_minimizer(uint64_t kmer) {
    uint8_t nt = tax_globals.ml;
    uint8_t key_bits = tax_globals.kl*2;
    uint64_t xor_mask = tax_globals.INDEX2_XOR_MASK;
    uint64_t mask = 1 << (nt * 2);
    mask--;
    xor_mask &= mask;
    uint64_t min_bin_key = ~0;
    uint64_t i = 0;
    for (i = 0; i < key_bits / 2 - nt + 1; i++) {
        uint64_t temp_bin_key = xor_mask ^ canonical_representation(kmer & mask, nt);
        if (temp_bin_key < min_bin_key)
            min_bin_key = temp_bin_key;
        kmer >>= 2;
    }
    return min_bin_key;
}

// Lexicographically smallest of k-mer and reverse comp. of k-mer // kraken source
uint64_t canonical_representation(uint64_t kmer, uint8_t n) {
    uint64_t revcom = reverse_complement(kmer, n);
    return kmer < revcom ? kmer : revcom;
}


//kraken source
uint64_t canonical_representation2(uint64_t kmer) {
    uint64_t revcom = reverse_complement(kmer, tax_globals.kl);
    return kmer < revcom ? kmer : revcom;
}

// Code mostly from Jellyfish 1.6 source //kraken source
uint64_t reverse_complement(uint64_t kmer, uint8_t n) {
    kmer = ((kmer >> 2)  & 0x3333333333333333UL) | ((kmer & 0x3333333333333333UL) << 2);
    kmer = ((kmer >> 4)  & 0x0F0F0F0F0F0F0F0FUL) | ((kmer & 0x0F0F0F0F0F0F0F0FUL) << 4);
    kmer = ((kmer >> 8)  & 0x00FF00FF00FF00FFUL) | ((kmer & 0x00FF00FF00FF00FFUL) << 8);
    kmer = ((kmer >> 16) & 0x0000FFFF0000FFFFUL) | ((kmer & 0x0000FFFF0000FFFFUL) << 16);
    kmer = ( kmer >> 32                        ) | ( kmer                         << 32);
    return (((uint64_t)-1) - kmer) >> (8 * sizeof(kmer) - (n << 1));
}

int next_kmer(char * read_seq, uint64_t * kmer){
    int j = 0;
    *kmer = 0;
    while(j < tax_globals.kl){ //generates kmer and checks for unsupported nucleotides
        (*kmer) <<= 2;
        if(read_seq[j] == 'A'){
            j++;
            continue;
        }
        else if(read_seq[j] == 'T'){
            (*kmer) |= 3;
            j++;
            continue;
        }
        else if(read_seq[j] == 'C'){
            (*kmer) |= 1;
            j++;
            continue;
        }
        else if(read_seq[j] == 'G'){
            (*kmer) |= 2;
            j++;
            continue;
        }
        else{
            return j;
        }
    }
    
    return tax_globals.KMER_FLAG;
}

//uint8_t collapsed_codon_vals[64] = {1, 1, 1, 1, 4, 4, 4, 4, 1, 9, 1, 9, 44, 44, 44, 44, 1, 19, 1, 19, 23, 23, 23, 23, 1, 1, 1, 1, 44, 44, 44, 44, 1, 1, 1, 1, 36, 36, 36, 36, 9, 9, 9, 9, 44, 44, 44, 44, 50, 63, 50, 63, 9, 9, 9, 9, 50, 44, 58, 44, 44, 63, 44, 63}; //generated by codon_to_int.py

uint8_t collapsed_codon_vals[64] = {2, 1, 2, 1, 9, 9, 9, 9, 2, 9, 2, 9, 13, 13, 14, 13, 34, 19, 34, 19, 23, 23, 23, 23, 2, 2, 2, 2, 13, 13, 13, 13, 34, 35, 34, 35, 36, 36, 36, 36, 43, 43, 43, 43, 13, 13, 13, 13, 50, 63, 50, 63, 9, 9, 9, 9, 50, 59, 58, 59, 13, 63, 13, 63};

uint8_t codon_vals[64] = {2, 1, 2, 1, 4, 4, 4, 4, 10, 9, 10, 9, 13, 13, 14, 13, 16, 19, 16, 19, 23, 23, 23, 23, 10, 10, 10, 10, 31, 31, 31, 31, 34, 35, 34, 35, 36, 36, 36, 36, 43, 43, 43, 43, 44, 44, 44, 44, 50, 51, 50, 51, 9, 9, 9, 9, 50, 59, 58, 59, 31, 63, 31, 63}; //generated by codon_to_int.py

#define CODON 3

int next_protein_kmer(char * read_seq, uint64_t * kmer){
    int j = 0;
    *kmer = 0;
    while(j+CODON <= tax_globals.kl){ //generates kmer and checks for unsupported nucleotides
        (*kmer) <<= 2*CODON;
        uint8_t codon = 0;
        int i=0;
        while (i < CODON) {
            codon <<= 2;
            if(read_seq[j+i] == 'A'){
                i++;
                continue;
            }
            else if(read_seq[j+i] == 'T'){
                codon |= 3;
                i++;
                continue;
            }
            else if(read_seq[j+i] == 'C'){
                codon |= 1;
                i++;
                continue;
            }
            else if(read_seq[j+i] == 'G'){
                codon |= 2;
                i++;
                continue;
            }
            else{
                return j+i;
            }
        }
        if (codon > 63 || codon < 0) {
            printf("problem, codon should not be greater than 63 or less than 0!\n from read seq %s\n",read_seq);
            return j+i;
        }
        uint8_t codon_val = tax_globals.afterburner == 0 ? codon_vals[codon] : collapsed_codon_vals[codon];
        (*kmer) |= (codon_val & 0x3F);
        j += CODON;
    }
    
    return tax_globals.KMER_FLAG;
}

void set_tax_globals(){
    tax_globals.kmer_cutoff = 10000;
    tax_globals.tax_cutoff = 500;
    tax_globals.kl = 31;
    tax_globals.ml = 15;
    tax_globals.KMER_FLAG = -1;
    tax_globals.KMER_NOT_FOUND = 7;
    tax_globals.INDEX2_XOR_MASK = 0xe37e28c4271b5a2dULL;
    tax_globals.output_ties = 0;
    tax_globals.total_kmer_count = 0;
    tax_globals.unique_kmer_count = 0;
    tax_globals.protein = 0;
    tax_globals.afterburner = 0;
    tax_globals.load_mem = 1;
    tax_globals.np = 1;
}
